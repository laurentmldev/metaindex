package metaindex.data.term.dbinterface;

/*
GNU GENERAL PUBLIC LICENSE
Version 3, 29 June 2007

Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>

See full version of LICENSE in <https://fsf.org/>

*/

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.elasticsearch.ElasticsearchException;

import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.indices.GetMappingsRequest;
import org.elasticsearch.client.indices.GetMappingsResponse;
import org.elasticsearch.cluster.metadata.MappingMetadata;

import metaindex.data.catalog.Catalog;
import metaindex.data.catalog.ICatalog;
import metaindex.data.term.ICatalogTerm;
import metaindex.data.term.ICatalogTerm.RAW_DATATYPE;
import toolbox.database.elasticsearch.ElasticSearchConnector;
import toolbox.database.elasticsearch.ESPopulateStmt;
import toolbox.database.elasticsearch.ESReadStreamStmt;
import toolbox.exceptions.DataProcessException;

/**
 * Consist in loading mapping defined for given index in ElasticSearch.
 * Result is stored as a set of terms which might be completed with
 * applicative complementary information defined in SQL database.
 * @see Catalog.updateTermsMapping
 * @see Catalog.updateTermsApplicativeInfo
 * @author laurentml
 *
 */
public class LoadMappingFromDbStmt extends ESPopulateStmt<ICatalog>   {

	private Log log = LogFactory.getLog(Catalog.class);
	
	private List<ICatalog> _catalogs;
	GetMappingsRequest _request;
	
	public LoadMappingFromDbStmt(List<ICatalog> c,ElasticSearchConnector ds) throws DataProcessException { 
		super(ds);
		_catalogs=c;
	 			
		_request = new GetMappingsRequest(); 
		String indiciesStr="";
		for (ICatalog catalog : _catalogs) {
			if (indiciesStr.length()>0) { indiciesStr+=","; }
			indiciesStr+=catalog.getName();	
		}
		
		_request.indices(indiciesStr);
		
	}

	
	@SuppressWarnings("unchecked")
	@Override
	public void execute() throws DataProcessException {
		try {
			
			GetMappingsResponse getMappingResponse = 
					this.getDataConnector().getHighLevelClient().indices().getMapping(
							_request, RequestOptions.DEFAULT);

			Map<String, MappingMetadata> allMappings = getMappingResponse.mappings();
			for (ICatalog c : _catalogs) { 
				
				Map<String,RAW_DATATYPE> catalogMapping = new HashMap<>();
				// store complementary info for more complex mappings like 'join' fields
				Map<String,Map<String,Object>> catalogMappingProperties = new HashMap<>();
				
				MappingMetadata indexMapping = allMappings.get(c.getName());
				if (indexMapping==null) {
					log.error("No such index '"+c.getName()+"' in retrieved contents from ElasticSearch.");
					continue;
				}
				Map<String, Object> mapping = indexMapping.sourceAsMap();
				Object fields = mapping.get("properties");
				if (fields!=null) {
					Map<String, Object> fieldsMap = new LinkedHashMap<String,Object>();
					
					try { fieldsMap = fieldsMap.getClass().cast(fields);} 
					catch (ClassCastException e) { throw new DataProcessException("unable to decode mapping list for catalog "+c.getName()); }
					
					for (String fieldName : fieldsMap.keySet()) {
						
						Map<String, Object> fieldPropertiesMap=new LinkedHashMap<String,Object>();
						
						try { fieldPropertiesMap = fieldPropertiesMap.getClass().cast(fieldsMap.get(fieldName));} 
						catch (ClassCastException e) { throw new DataProcessException("unable to decode mapping list for catalog "+c.getName()); }
						
						// assume if previous cast worked fine, this one will do so too ...
						String typeStr = (String) fieldPropertiesMap.get("type");
						 
						RAW_DATATYPE type = ICatalogTerm.getRawDatatype(typeStr);
						
						catalogMapping.put(fieldName, type);
						// using Map generated by ElasticSearch API as is
						catalogMappingProperties.put(fieldName,fieldPropertiesMap);
						
					}
					c.updateTermsMapping(catalogMapping,catalogMappingProperties);			
				}
			}
			
		} catch (ElasticsearchException e) {
			e.printStackTrace();
			throw new DataProcessException(e.getRootCause().getMessage(),e);
		}
		catch (Exception e) {
			e.printStackTrace();
			throw new DataProcessException(e.getMessage(),e);
		}
	}					
};
